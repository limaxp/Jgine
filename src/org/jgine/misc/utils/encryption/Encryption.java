package org.jgine.misc.utils.encryption;

import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.Key;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.spec.InvalidKeySpecException;
import java.util.Arrays;
import java.util.Base64;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.KeyGenerator;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;
import javax.security.auth.DestroyFailedException;
import javax.security.auth.Destroyable;

import org.jgine.misc.utils.Reflection;
import org.jgine.misc.utils.logger.Logger;

public class Encryption {

	private static final String ALGORITHM = "AES";
	private static final String MODE = "GCM/NoPadding";
	private static final int KEY_SIZE = 256;
	private static final int AUTH_TAG_SIZE = 128;
	private static final int IV_LENGTH = 12;
	private static final int ITERATION_COUNT = 40000;
	// Used to keep track of random number bytes generated by SECURE_RANDOM
	// (for the purpose of re-seeding)
	private static int bytesGenerated = 0;
	// number of random number bytes generated before re-seeding
	private static final double PRNG_RESEED_INTERVAL = Math.pow(2, 16);
	private static final Cipher CIPHER;
	private static final SecureRandom SECURE_RANDOM;

	static {
		try {
			CIPHER = Cipher.getInstance(ALGORITHM + '/' + MODE);
		} catch (NoSuchAlgorithmException | NoSuchPaddingException e) {
			Logger.err("Encryption: Error initializing Cipher!", e);
			throw new RuntimeException(e);
		}
		try {
			SECURE_RANDOM = SecureRandom.getInstanceStrong();
		} catch (NoSuchAlgorithmException e) {
			Logger.err("Encryption: Error initializing SecureRandom!", e);
			throw new RuntimeException(e);
		}
	}

	public static byte[] encrypt(byte[] data, Key key) {
		byte[] iv = generateIv(IV_LENGTH);
		GCMParameterSpec ivSpec = new GCMParameterSpec(AUTH_TAG_SIZE, iv);
		byte[] encrypted;
		try {
			CIPHER.init(Cipher.ENCRYPT_MODE, key, ivSpec);
			encrypted = CIPHER.doFinal(data);
		} catch (InvalidKeyException | InvalidAlgorithmParameterException | IllegalBlockSizeException
				| BadPaddingException e) {
			Logger.err("Encryption: Error encrypting data!", e);
			return null;
		}

		byte[] result = new byte[encrypted.length + IV_LENGTH];
		System.arraycopy(iv, 0, result, 0, IV_LENGTH);
		System.arraycopy(encrypted, 0, result, IV_LENGTH, encrypted.length);
		return base64Encode(result);
	}

	public static byte[] decrypt(byte[] data, Key key) {
		data = base64Decode(data);
		byte[] iv = new byte[IV_LENGTH];
		byte[] encrypted = new byte[data.length - IV_LENGTH];
		System.arraycopy(data, 0, iv, 0, IV_LENGTH);
		System.arraycopy(data, IV_LENGTH, encrypted, 0, data.length - IV_LENGTH);
		GCMParameterSpec ivSpec = new GCMParameterSpec(AUTH_TAG_SIZE, iv);
		try {
			CIPHER.init(Cipher.DECRYPT_MODE, key, ivSpec);
			return CIPHER.doFinal(encrypted);
		} catch (InvalidKeyException | InvalidAlgorithmParameterException | IllegalBlockSizeException
				| BadPaddingException e) {
			Logger.err("Encryption: Error decrypting data!", e);
			return null;
		}
	}

	public static SecretKey createKey(byte[] data) {
		return new SecretKeySpec(data, ALGORITHM);
	}

	public static SecretKey generateKey() {
		SecureRandom secureRandom;
		try {
			secureRandom = SecureRandom.getInstanceStrong();
		} catch (NoSuchAlgorithmException e) {
			Logger.err("Encryption: Error getting SecureRandom instance!", e);
			return null;
		}
		KeyGenerator keyGen;
		try {
			keyGen = KeyGenerator.getInstance(ALGORITHM);
		} catch (NoSuchAlgorithmException e) {
			Logger.err("Encryption: Error initializing KeyGenerator for algorithm " + ALGORITHM, e);
			return null;
		}
		keyGen.init(KEY_SIZE, secureRandom);
		return keyGen.generateKey();
	}

	public static SecretKey generateKey(char[] data) {
		return generateKey(data, ITERATION_COUNT);
	}

	public static SecretKey generateKey(char[] data, int iterationCount) {
		SecureRandom secureRandom;
		try {
			secureRandom = SecureRandom.getInstanceStrong();
		} catch (NoSuchAlgorithmException e) {
			Logger.err("Encryption: Error getting SecureRandom instance!", e);
			return null;
		}
		byte[] salt = new byte[32];
		secureRandom.nextBytes(salt);
		return generateKey(data, salt, ITERATION_COUNT);
	}

	public static SecretKey generateKey(char[] data, byte[] salt) {
		return generateKey(data, salt, ITERATION_COUNT);
	}

	public static SecretKey generateKey(char[] data, byte[] salt, int iterationCount) {
		try {
			SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA512");
			PBEKeySpec keySpec = new PBEKeySpec(data, salt, iterationCount, KEY_SIZE);
			SecretKey keyTmp = keyFactory.generateSecret(keySpec);
			SecretKeySpec key = new SecretKeySpec(keyTmp.getEncoded(), ALGORITHM);
			clearKey(keyTmp);
			return key;
		} catch (NoSuchAlgorithmException | InvalidKeySpecException e) {
			Logger.err("Encryption: Error generating key for algorithm " + ALGORITHM, e);
			return null;
		}
	}

	public static void clearKey(Destroyable key) {
		// this might do something otherwise ignore since not supported!
		try {
			key.destroy();
		} catch (DestroyFailedException ignore) {
		}
		try {
			byte[] encodedKey = (byte[]) Reflection.getFieldValue(key, "key");
			Arrays.fill(encodedKey, Byte.MIN_VALUE);
		} catch (Exception ignore) {
		}
	}

	private static byte[] generateIv(int numBytes) {
		if (bytesGenerated > PRNG_RESEED_INTERVAL || bytesGenerated == 0) {
			SECURE_RANDOM.setSeed(SECURE_RANDOM.generateSeed(numBytes));
			bytesGenerated = 0;
		}
		byte[] iv = new byte[numBytes];
		SECURE_RANDOM.nextBytes(iv);
		bytesGenerated += numBytes;
		return iv;
	}

	public static byte[] digest(byte[] data) {
		MessageDigest messageDigest;
		try {
			messageDigest = MessageDigest.getInstance("SHA-256");
		} catch (NoSuchAlgorithmException e) {
			Logger.err("Encryption: Error getting MessageDigest instance!", e);
			return null;
		}
		return base64Encode(messageDigest.digest(data));
	}

	private static byte[] base64Encode(byte[] data) {
		return Base64.getEncoder().encode(data);
	}

	private static byte[] base64Decode(byte[] data) {
		return Base64.getDecoder().decode(data);
	}
}
